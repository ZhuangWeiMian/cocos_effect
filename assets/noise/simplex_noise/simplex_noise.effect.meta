{
  "ver": "1.0.27",
  "uuid": "b8cdba31-0067-4189-b1d9-ae26d713aa74",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvarying vec4 v_pos;\n#if USE_TEXTURE\n  attribute vec2 a_uv0;\n  varying vec2 v_uv0;\n#endif\nvoid main() {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n    v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  v_pos = pos;\n  gl_Position = pos;\n}",
        "frag": "\nprecision mediump float;\n#if USE_ALPHA_TEST\n#endif\nvarying vec4 v_pos;\n#if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n#endif\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 permute(vec3 x) {\n  return mod289(((x * 34.0) + 10.0) * x);\n}\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187,\n  0.366025403784439,\n  - 0.577350269189626,\n0.024390243902439);\nvec2 i = floor(v + dot(v, C.yy));\nvec2 x0 = v - i + dot(i, C.xx);\nvec2 i1;\ni1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\nvec4 x12 = x0.xyxy + C.xxzz;\nx12.xy -= i1;\ni = mod289(i);\nvec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n+ i.x + vec3(0.0, i1.x, 1.0));\nvec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\nm = m*m ;\nm = m*m ;\nvec3 x = 2.0 * fract(p * C.www) - 1.0;\nvec3 h = abs(x) - 0.5;\nvec3 ox = floor(x + 0.5);\nvec3 a0 = x - ox;\nm *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h*h);\nvec3 g;\ng.x = a0.x * x0.x + h.x * x0.y;\ng.yz = a0.yz * x12.xz + h.yz * x12.yw;\nreturn 130.0 * dot(m, g);\n}\nvoid main() {\nvec3 color = vec3(0.0);\nvec2 st = v_pos.xy;\nvec2 pos = vec2(st * 10.0);\ncolor = vec3(snoise(pos) * 0.5 + 0.5);\ngl_FragColor = vec4(1.0 - color, 1.0);\n}"
      },
      "glsl3": {
        "vert": "\nprecision mediump float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nout vec4 v_pos;\n#if USE_TEXTURE\n  in vec2 a_uv0;\n  out vec2 v_uv0;\n#endif\nvoid main() {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n    v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  v_pos = pos;\n  gl_Position = pos;\n}",
        "frag": "\nprecision mediump float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nin vec4 v_pos;\n#if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n#endif\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 permute(vec3 x) {\n  return mod289(((x * 34.0) + 10.0) * x);\n}\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187,\n  0.366025403784439,\n  - 0.577350269189626,\n0.024390243902439);\nvec2 i = floor(v + dot(v, C.yy));\nvec2 x0 = v - i + dot(i, C.xx);\nvec2 i1;\ni1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\nvec4 x12 = x0.xyxy + C.xxzz;\nx12.xy -= i1;\ni = mod289(i);\nvec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n+ i.x + vec3(0.0, i1.x, 1.0));\nvec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\nm = m*m ;\nm = m*m ;\nvec3 x = 2.0 * fract(p * C.www) - 1.0;\nvec3 h = abs(x) - 0.5;\nvec3 ox = floor(x + 0.5);\nvec3 a0 = x - ox;\nm *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h*h);\nvec3 g;\ng.x = a0.x * x0.x + h.x * x0.y;\ng.yz = a0.yz * x12.xz + h.yz * x12.yw;\nreturn 130.0 * dot(m, g);\n}\nvoid main() {\nvec3 color = vec3(0.0);\nvec2 st = v_pos.xy;\nvec2 pos = vec2(st * 10.0);\ncolor = vec3(snoise(pos) * 0.5 + 0.5);\ngl_FragColor = vec4(1.0 - color, 1.0);\n}"
      }
    }
  ],
  "subMetas": {}
}